# java中常用的锁机制

**什么是锁**

锁(lock)是一种同步机制, 用于在有许多执行线程的环境中强制对资源的访问限制.锁旨在强制实施互斥排他、 并发控制策略.

> 锁通常需要硬件支持才能有效实施. 这种支持通常采用一个或者多个原子指令的形式, 如"test-and-set", "fetch-and-add" 或者 "compare-and-swap". 这些指令允许单个进程测试锁是否空闲, 如果空闲, 则通过单个原子操作获取锁.

**锁的几个概念**

1. 锁开销(lock overhead): 锁占用内存空间、cpu初始化和销毁锁、获取和释放锁的时间.程序使用的锁越多, 响应的锁开销越大.
2. 锁竞争(lock contention): 一个进程或线程试图获取另一个进程或线程持有的锁, 就会发生锁竞争. 锁粒度越小, 发生锁竞争的可能性就越小.
3. 死锁(deadlock): 至少两个任务中的每一个都等待另一个任务持有的锁的情况, 锁粒度是衡量锁保护的数据量的大小, 通常选择粗粒度的锁(锁的数量少，每个锁保护大量的数据)，在当单进程访问受保护的数据时锁开销小，但是当多个进程同时访问时性能很差。因为增大了锁的竞争。相反，使用细粒度的锁(锁数量多，每个锁保护少量的数据)增加了锁的开销但是减少了锁竞争。例如数据库中，锁的粒度有表锁、页锁、行锁、字段锁、字段的一部分锁.

> 相关术语  Critical Section(临界区)、 Mutex/mutual exclusion(互斥体)、 Semaphore/binary semaphore(信号量).

**锁的种类**

1. 独享锁/共享锁: 独享锁是指该锁一次只能被一个线程所持有. ReentrantLock、 Synchronized都是独享锁。共享锁是指该锁可被多个线程所持有。Lock的另一个实现类ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。

2. 互斥锁/读写锁: 上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在Java中的具体实现就是ReentrantLock，读写锁在Java中的具体实现就是ReentrantReadWriteLock.

3. 公平锁/非公平锁: 公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。

4. 乐观锁/悲观锁: 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

5. 可重入锁: 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Reentrant Lock重新进入锁。对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。



> 参考: https://segmentfault.com/a/1190000013512810 https://blog.csdn.net/u010648018/article/details/79750608
